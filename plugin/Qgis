import sys
import os
import pandas as pd
import numpy as np

# Tenta importar bibliotecas opcionais
try:
    from scipy.stats import shapiro
    HAS_SHAPIRO = True
except:
    HAS_SHAPIRO = False

import matplotlib.pyplot as plt

try:
    import seaborn as sns
    HAS_SEABORN = True
except:
    HAS_SEABORN = False


# ===================== FUNÇÕES =====================

def load_data(path):
    """
    Carrega o arquivo Excel e valida colunas reais:
    PONTO, X, Y, DISTANCIA
    """
    if not os.path.exists(path):
        raise FileNotFoundError(f"Arquivo não encontrado: {path}")

    df = pd.read_excel(path)
    expected = ["PONTO", "X", "Y", "DISTANCIA"]

    missing = [c for c in expected if c not in df.columns]
    if missing:
        raise KeyError(f"Colunas faltando: {missing} - esperado: {expected}")

    df = df.copy()
    df["X"] = pd.to_numeric(df["X"], errors="coerce")
    df["Y"] = pd.to_numeric(df["Y"], errors="coerce")
    df["DISTANCIA"] = pd.to_numeric(df["DISTANCIA"], errors="coerce")
    df = df.dropna(subset=["X", "Y", "DISTANCIA"]).reset_index(drop=True)

    return df


def descriptive_stats(df):
    """ Calcula estatísticas descritivas para X, Y e DISTANCIA. """
    stats = df[["X", "Y", "DISTANCIA"]].describe().T
    stats["%_positivos"] = (df[["X", "Y", "DISTANCIA"]] > 0).sum() / len(df) * 100
    stats["%_negativos"] = (df[["X", "Y", "DISTANCIA"]] < 0).sum() / len(df) * 100
    return stats


def normality(df):
    """ Testa normalidade da coluna DISTANCIA (Shapiro) """
    if not HAS_SHAPIRO:
        return None, None
    vals = df["DISTANCIA"].dropna().values
    if len(vals) < 3:
        return None, None
    return shapiro(vals)


# ===================== GRÁFICOS =====================

def plot_scatter(df):
    x = df["X"].values
    y = df["Y"].values
    dist = df["DISTANCIA"].values
    plt.scatter(x, y, c=dist, cmap="viridis")
    plt.colorbar(label="DISTANCIA")
    plt.xlabel("X")
    plt.ylabel("Y")
    plt.title("Dispersão X vs Y (cor = DISTANCIA)")
    plt.show()


def plot_hist(df):
    plt.hist(df["DISTANCIA"].dropna().values, bins=30)
    plt.title("Histograma - DISTANCIA")
    plt.xlabel("DISTANCIA")
    plt.ylabel("Frequência")
    plt.show()


def plot_cdf(df):
    vals = np.sort(df["DISTANCIA"].dropna().values)
    cdf = np.arange(1, len(vals) + 1) / len(vals)
    plt.plot(vals, cdf)
    plt.grid(True)
    plt.title("Distribuição Acumulada (CDF) - DISTANCIA")
    plt.xlabel("DISTANCIA")
    plt.ylabel("Fração acumulada")
    plt.show()


def plot_box_violin(df):
    vals = df["DISTANCIA"].dropna().values
    plt.figure(figsize=(8,4))
    if HAS_SEABORN:
        sns.boxplot(x=vals)
        sns.violinplot(x=vals, inner="quartile", color="lightgray")
        plt.title("Box + Violin - DISTANCIA")
    else:
        plt.boxplot(vals, vert=False)
        plt.title("BoxPlot - DISTANCIA")
    plt.xlabel("DISTANCIA")
    plt.show()


# ===================== MAIN =====================

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("\nUso:\n   python analise_outlayer.py caminho_do_arquivo.xlsx\n")
        sys.exit()

    datafile = sys.argv[1]
    df = load_data(datafile)

    print("\n=== Estatísticas Descritivas ===\n")
    print(descriptive_stats(df))

    stat, pvalue = normality(df)
    if stat is None:
        print("\nTeste de normalidade não executado (SciPy não disponível ou dados insuficientes).")
    else:
        print(f"\nShapiro-Wilk: stat={stat:.6f}, p={pvalue:.6f}")

    print("\nGerando gráficos...")

    plot_scatter(df)
    plot_hist(df)
    plot_cdf(df)
    plot_box_violin(df)